#RLP算法解析#
## RLP原理

[**RLP**](https://github.com/ethereum/wiki/wiki/RLP)([Recursive Length Prefix，递归长度前缀]是一种编码算法，用于编码任意的嵌套结构的二进制数据，它是以太坊中数据序列化/反序列化的主要方法，区块、交易等数据结构在持久化时会先经过RLP编码后再存储到数据库中。
	
RLP编码的定义只处理两类数据：一类是字符串（例如字节数组），一类是列表。字符串指的是一串二进制数据，列表是一个嵌套递归的结构，里面可以包含字符串和列表，例如[“cat”,[“puppy","cow"],"horse",[[]],"pig",[""],"sheep"]就是一个复杂的列表。其他类型的数据需要转成以上的两类，转换的规则不是RLP编码定义的，可以根据自己的规则转换。
	
RLP编码规则：

*	对于布尔类型，true编码为0x01；false编码为0x80

*	对于整数类型，如果值为0，则编码为0；如果它的值范围是（0x00, 0x7f]，它的RLP编码就是它本身。否则，RLP编码为 0x80+大端编码的字节个数，大端编码字节

* 	对于字符串，如果一个字符串的长度是0-55字节，它的RLP编码包含一个单字节的前缀，后面跟着字符串本身，这个前缀的值是0x80加上字符串的长度。由于被编码的字符串最大长度是55=0x37,因此单字节前缀的最大值是0x80+0x37=0xb7，即编码的第一个字节的取值范围是[0x80, 0xb7]。

*	如果字符串的长度大于55个字节，它的RLP编码包含一个单字节的前缀，后面跟着字符串的长度，后面再跟着字符串本身。这个前缀的值是0xb7加上字符串长度的二进制形式的字节长度，说的有点绕，举个例子就明白了，例如一个字符串的长度是1024，它的二进制形式是10000000000，这个二进制形式的长度是2个字节，所以前缀应该是0xb7+2=0xb9，字符串长度1024=0x400，因此整个RLP编码应该是\xb9\x04\x00再跟上字符串本身。编码的第一个字节即前缀的取值范围是[0xb8, 0xbf]，因为字符串长度二进制形式最少是1个字节，因此最小值是0xb7+1=0xb8，字符串长度二进制最大是8个字节，因此最大值是0xb7+8=0xbf。

*	如果一个列表的总长度（列表的总长度指的是它包含的项的数量加它包含的各项的长度之和）是0-55字节，它的RLP编码包含一个单字节的前缀，后面跟着列表中各元素项的RLP编码，这个前缀的值是0xc0加上列表的总长度。编码的第一个字节的取值范围是[0xc0, 0xf7]。

* 	如果一个列表的总长度大于55字节，它的RLP编码包含一个单字节的前缀，后面跟着列表的长度，后面再跟着列表中各元素项的RLP编码，这个前缀的值是0xf7加上列表总长度的二进制形式的字节长度。编码的第一个字节的取值范围是[0xf8, 0xff]。
	
RLP解码规则：

根据RLP编码规则和过程，RLP解码的输入一律视为二进制字符数组，其过程如下：

*	根据输入首字节数据，解码数据类型、实际数据长度和位置；

*	根据类型和实际数据，解码不同类型的数据；

*	继续解码剩余的数据；
	其中，解码数据类型、实际数据类型和位置的规则如下：
	*	如果首字节(prefix)的值在[0x00, 0x7f]范围之间，那么该数据是字符串，且字符串就是首字节本身；
	
	*	如果首字节的值在[0x80, 0xb7]范围之间，那么该数据是字符串，且字符串的长度等于首字节减去0x80，且字符串位于首字节之后；
	
	*	如果首字节的值在[0xb8, 0xbf]范围之间，那么该数据是字符串，且字符串的长度的字节长度等于首字节减去0xb7，数据的长度位于首字节之后，且字符串位于数据的长度之后；
	
	*	如果首字节的值在[0xc0, 0xf7]范围之间，那么该数据是列表，在这种情况下，需要对列表各项的数据进行递归解码。列表的总长度（列表各项编码后的长度之和）等于首字节减去0xc0，且列表各项位于首字节之后；
	
	*	如果首字节的值在[0xf8, 0xff]范围之间，那么该数据为列表，列表的总长度的字节长度等于首字节减去0xf7，列表的总长度位于首字节之后，且列表各项位于列表的总长度之后；
	
## 示例
### 编码示例
	结构体定义
	type simplestruct struct {
		A uint
		B string
	}

<table>
	<tr>
		<th>类型</th>
		<th>输入</th>
		<th>输出</th>
	</tr>
	<tr>
		<td width="20%">bool类型</td>
		<td>true</td>
		<td>0x01</td>
	</tr>
	<tr>
		<td>bool类型</td>
		<td>false</td>
		<td>0x80</td>
	</tr>
	<tr>
		<td>整数类型</td>
		<td>0</td>
		<td>0x80</td>
	</tr>
	<tr>
		<td>整数类型</td>
		<td>127</td>
		<td>0x7F</td>
	</tr>
	<tr>
		<td>整数类型</td>
		<td>128</td>
		<td>0x8180</td>
	</tr>
	<tr>
		<td>整数类型</td>
		<td>0xFFFFFF</td>
		<td>0x83FFFFFF</td>
	</tr>
	<tr>
		<td>整数类型</td>
		<td>0xFFFFFFFF</td>
		<td>0x84FFFFFFFF</td>
	</tr>
	<tr>
		<td>整数类型</td>
		<td>0xFFFFFFFFFF</td>
		<td>0x85FFFFFFFFFF</td>
	</tr>
	<tr>
		<td>整数类型</td>
		<td>0xFFFFFFFFFFFFFF</td>
		<td>0x87FFFFFFFFFFFFFF</td>
	</tr>
	<tr>
		<td>整数类型</th>
		<td>0xFFFFFFFFFFFFFFFF</td>
		<td>0x88FFFFFFFFFFFFFFFF</td>
	</tr>
	<tr>
		<td>整数类型</td>
		<td>0x75BCD15</td>
		<td>0x8475BCD15</td>
	</tr>
	<tr>
		<td>字符串</td>
		<td>“dog"</td>
		<td>0x83646f67 => 0x83,'d','o','g'</th>
	</tr>
	<tr>
		<td>结构体</td>
		<td>simplestruct{}</td>
		<td>0xc28080</td>
	</tr>
	<tr>
		<td>结构体</td>
		<td>simplestruct{3,"foo"}</td>
		<td>0xc50383666f6f</td>
	</tr>
</table>